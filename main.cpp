
#include "AceHeaders.h"

#include "Diameter.h"
#include "DccFrame.h"

#include <fstream>
#include <iostream>
#include <string>
#include <cassert>

using namespace std;


typedef struct {
	string ip;
	int port;

	string product_name;
	string origin_host;
	string origin_realm;
	string dst_host;
	string dst_realm;
	string service_context_id;
	string host_ip_address_value;
	int vendor_id;
	int supported_vendor_id;
	int auth_application_id;
	int acct_application_id;
	int inband_security_id;
	int firmware_revision;

	string user_number;
}BOSS_INFO;

int gl_seqno = 41;


string formated_timestamp()
{
	ACE_Date_Time dt(ACE_OS::gettimeofday());
	
	char buf[15] = { 0 };
	sprintf(buf, "%04d%02d%02d%02d%02d%02d", dt.year(), dt.month(), dt.day(), dt.hour(), dt.minute(), dt.second());
	return buf;
}


static uint32_t timestamp()
{
	timeval t = ACE_OS::gettimeofday();
	return t.tv_sec;
}

void hex_dump(char* buffer, size_t length)
{
	printf("\n==========HEX DUMP BEGIN [%d] ================\n", length);
	for (size_t i = 0; i < length; i++)
	{
		if (i && i % 16 == 0)
		{
			printf("\n");
		}
		printf("%02X ", (unsigned char)buffer[i]);
	}
	printf("\n==========HEX DUMP END   [%d]=================\n", length);
}


int send_dpr(ACE_SOCK_Stream* peer, BOSS_INFO& info)
{
	char buf[1024];
	int result;
	size_t length, byte_trans;
	DisconnectPeerRequest dpr;

	dpr.origin_host = info.origin_host;
	dpr.origin_realm = info.origin_realm;

	memset(buf, 0, sizeof(buf));
	result = dpr.serialize((uint8_t*)buf, sizeof(buf), ++gl_seqno);
	if (result <= 0)
	{
		ERROR("dpr serialize error.", "");
		return -1;
	}
	length = result;

	result = peer->send_n(buf, length, 0, &byte_trans);
	if (result <= 0)
	{
		ERROR("send dpr error.", "");
		return -1;
	}

	return 0;
}


int send_dwr(ACE_SOCK_Stream* peer, BOSS_INFO& info)
{
	char buf[1024];
	int result;
	size_t length, byte_trans;
	DeviceWatchdogRequest dwr;

	dwr.origin_host = info.origin_host;
	dwr.origin_realm = info.origin_realm;

	memset(buf, 0, sizeof(buf));
	result = dwr.serialize((uint8_t*)buf, sizeof(buf), ++gl_seqno);
	if (result <= 0)
	{
		ERROR("dwr serialize error.", "");
		return -1;
	}
	length = result;

	result = peer->send_n(buf, length, 0, &byte_trans);
	if (result <= 0)
	{
		ERROR("send dwr error.", "");
		return -1;
	}

	return 0;
}


int send_ccr(ACE_SOCK_Stream* peer)
{
	CreditControlRequest ccr;

	return 0;
}


int auth(ACE_SOCK_Stream* peer, BOSS_INFO& info)
{
	char buf[1024];
	size_t byte_trans, length;
	CapabilitiesExchangeRequest cer;

	cer.header.flags.flag_r = 1;
	cer.origin_host = info.origin_host;
	cer.origin_realm = info.origin_realm;

	cer.host_ip_address = info.host_ip_address_value;
	cer.product_name = info.product_name;
	cer.vendor_id = info.vendor_id;
	cer.origin_state_id = 0;
	cer.supported_vendor_id = info.supported_vendor_id;
	cer.auth_application_id = info.auth_application_id;
	cer.acct_application_id = info.acct_application_id;
	cer.inband_security_id = info.inband_security_id;
	cer.firmware_revision = info.firmware_revision;

	memset(buf, 0, sizeof(buf));
	int result = cer.serialize((uint8_t*)buf, sizeof(buf), ++gl_seqno);
	assert(result > 0);
	length = result;

	hex_dump(buf, length);

	result = peer->send_n(buf, length, 0, &byte_trans);
	if (result <= 0)
	{
		ERROR("send data error.", "");
	}

	return 0;
}


int get_cfg_int(ACE_Configuration_Heap& heap, ACE_Configuration_Section_Key& key, const string& name)
{
	ACE_TString value;
	int result = heap.get_string_value(key, name.c_str(), value);
	if (-1 == result)
	{
		printf("[%s] not configured.\n", name.c_str());
		return -1;
	}
	else
	{
		return atoi(value.c_str());
	}
}


string get_cfg_string(ACE_Configuration_Heap& heap, ACE_Configuration_Section_Key& key, const string& name)
{
	ACE_TString value;
	int result = heap.get_string_value(key, name.c_str(), value);
	if (-1 == result)
	{
		printf("[%s] not configured.\n", name.c_str());
		return "";
	}
	else
	{
		return value.c_str();
	}
}


int read_boss_cfg(BOSS_INFO& info)
{
	int result;
	ACE_Configuration_Heap cfg_heap;
	ACE_Ini_ImpExp ini(cfg_heap);

	cfg_heap.open();
	if (-1 == ini.import_config("cfg.ini"))
	{
		printf("cannot open config error.\n");
		return -1;
	}

	ACE_TString value;
	ACE_Configuration_Section_Key section;

	result = cfg_heap.open_section(cfg_heap.root_section(), "test", 0, section);
	if (-1 == result)
	{
		printf("section config error.");
		return -1;
	}

	info.product_name = get_cfg_string(cfg_heap, section, "product_name");
	info.origin_host = get_cfg_string(cfg_heap, section, "origin_host");
	info.origin_realm = get_cfg_string(cfg_heap, section, "origin_realm");
	info.dst_host= get_cfg_string(cfg_heap, section, "dst_host");
	info.dst_realm = get_cfg_string(cfg_heap, section, "dst_realm");
	info.service_context_id = get_cfg_string(cfg_heap, section, "service_context_id");
	info.host_ip_address_value = get_cfg_string(cfg_heap, section, "host_ip_address_value");

	info.vendor_id = get_cfg_int(cfg_heap, section, "vendor_id");
	info.supported_vendor_id = get_cfg_int(cfg_heap, section, "supported_vendor_id");
	info.auth_application_id = get_cfg_int(cfg_heap, section, "auth_application_id");
	info.acct_application_id = get_cfg_int(cfg_heap, section, "acct_application_id");
	info.inband_security_id = get_cfg_int(cfg_heap, section, "inband_security_id");
	info.firmware_revision = get_cfg_int(cfg_heap, section, "firmware_revision");

	info.user_number = get_cfg_string(cfg_heap, section, "user_number");
	info.ip = get_cfg_string(cfg_heap, section, "ip");
	info.port = get_cfg_int(cfg_heap, section, "port");
	return 0;
}


int recv_answer(ACE_SOCK_Stream* peer)
{
	int result;
	char buf[1024];
	size_t byte_trans;
	DiameterHeader header;

	result = peer->recv_n(buf, DIAMETER_HEADER_LENGTH, NULL, &byte_trans);
	if (result <= 0 && byte_trans != DIAMETER_HEADER_LENGTH)
	{
		printf("recv header error. [%d] [%d]\n", result, byte_trans);
		return -1;
	}


	result = header.parse_diameter_header((uint8_t*)buf);
	if (result < 0)
	{
		printf("Diameter header parser error.\n");
		return -1;
	}

	int left_bytes = header.length - DIAMETER_HEADER_LENGTH;
	result = peer->recv_n(buf + DIAMETER_HEADER_LENGTH, left_bytes, NULL, &byte_trans);
	if (result <= 0 && byte_trans != left_bytes)
	{
		WARNING("Diameter body recv error. result: [%d], byte_trans: [%d]", result, byte_trans);
		return -1;
	}

	hex_dump(buf, byte_trans + DIAMETER_HEADER_LENGTH);

	Diameter diameter;
	result = diameter.parse_from_buffer((uint8_t*)buf, header.length);
	if (result <= 0)
	{
		printf("Diameter deserialize error.\n");
		return -1;
	}
	else
	{
		//diameter.dump();
	}

	return 0;
}


int send_ccr_deposit(ACE_SOCK_Stream* peer, BOSS_INFO& info, const string& txid)
{
	CreditControlRequest ccr;
	ccr.timestamp = timestamp();
	ccr.origin_host = info.origin_host;
	ccr.origin_realm = info.origin_realm;

	//不用设置sessionid，serialize时拼接
	ccr.destination_host = info.dst_host;
	ccr.destination_realm = info.dst_realm;
	ccr.auth_application_id = 4;
	ccr.service_context_id = info.service_context_id;
	ccr.cc_request_type = 4;
	ccr.cc_request_number = 0;
	ccr.event_timestamp = ccr.timestamp;

	ccr.subscription_id_type = 0;
	ccr.subscription_id_data = info.user_number;

	ccr.requested_action = 0;
	ccr.service_identifier = 7;

	ccr.service_type = "01010301";
	ccr.transactionid = txid;
	ccr.trade_time = formated_timestamp();
	ccr.serialno = txid;
	ccr.oldserialno = "";

	ccr.recharge_number = info.user_number;
	ccr.money_value = 1000;
	ccr.accounttype = 3;
	ccr.recharge_method = "04";

	char buf[1024];
	int result = ccr.serialize((uint8_t*)buf, sizeof(buf), ++gl_seqno);
	printf("avp dump\n");
	//ccr.dump();

	printf("hex_dump\n");
	hex_dump(buf, result);
	peer->send_n(buf, result);
	printf("send over\n");

	return 0;
}


int send_ccr_reverse(ACE_SOCK_Stream* peer, BOSS_INFO& info, const string& txid, const string& rev_txid)
{
	CreditControlRequest ccr;
	ccr.timestamp = timestamp();
	ccr.origin_host = info.origin_host;
	ccr.origin_realm = info.origin_realm;

	//不用设置sessionid，serialize时拼接
	ccr.destination_host = info.dst_host;
	ccr.destination_realm = info.dst_realm;
	ccr.auth_application_id = 4;
	ccr.service_context_id = info.service_context_id;
	ccr.cc_request_type = 4;
	ccr.cc_request_number = 0;
	ccr.event_timestamp = ccr.timestamp;

	ccr.subscription_id_type = 0;
	ccr.subscription_id_data = info.user_number;

	ccr.requested_action = 0;
	ccr.service_identifier = 7;

	ccr.service_type = "01010401";
	ccr.transactionid = txid;
	ccr.trade_time = formated_timestamp();
	ccr.serialno = txid;
	ccr.oldserialno = rev_txid;

	ccr.recharge_number = info.user_number;
	ccr.money_value = 1000;

	ccr.accounttype = 3;
	ccr.recharge_method = "04";

	char buf[1024];
	int result = ccr.serialize((uint8_t*)buf, sizeof(buf), ++gl_seqno);
	printf("avp dump\n");
	//ccr.dump();

	printf("hex_dump\n");
	hex_dump(buf, result);
	peer->send_n(buf, result);
	printf("send over\n");

	return 0;
}


int view_avp();
int view_diameter();
int main(int argc, char** argv)
{
	view_diameter(); view_avp(); exit(0);
	gl_seqno = rand() % 100000;
	if (argc < 3)
	{
		printf("usage: deposit_txid reverse_txid\n");
		exit(1);
	}

	int result;
	BOSS_INFO info;
	if (read_boss_cfg(info) == -1) {
		printf("boss cfg read error.\n");
		exit(1);
	}

	ACE_SOCK_Stream peer;
	ACE_SOCK_Connector connector;
	ACE_INET_Addr addr(info.port, info.ip.c_str());

	result = connector.connect(peer, addr);
	if (result < 0)
	{
		printf("connect error.\n");
		exit(1);
	}
	printf("connect succ.\n");

	printf("================>>>>>>>>>>>>>> CER\n");
	auth(&peer, info);
	recv_answer(&peer);
	printf("================<<<<<<<<<<<<<<< CER\n");

	printf("================>>>>>>>>>>>>>> DWR\n");
	send_dwr(&peer, info);
	recv_answer(&peer);
	printf("================<<<<<<<<<<<<<<< DWR\n");

	ACE_OS::sleep(ACE_Time_Value(2, 0));
	printf("================>>>>>>>>>>>>>> CCR DEPOSIT\n");
	send_ccr_deposit(&peer, info, argv[1]);
	printf("================<<<<<<<<<<<<<<< CCR DEPOSIT\n");

	printf("================>>>>>>>>>>>>>> CCA DEPOSIT\n");
	recv_answer(&peer);
	printf("================<<<<<<<<<<<<<<< CCA DEPOSIT\n");

	printf("================>>>>>>>>>>>>>> CCR REVERSE\n");
	send_ccr_reverse(&peer, info, argv[2], argv[1]);
	printf("================<<<<<<<<<<<<<<< CCR REVERSE\n");

	printf("================>>>>>>>>>>>>>> CCA REVERSE\n");
	recv_answer(&peer);
	printf("================<<<<<<<<<<<<<<< CCA REVERSE\n");

	printf("================>>>>>>>>>>>>>> DPR\n");
	send_dpr(&peer, info);
	peer.close();
	printf("================<<<<<<<<<<<<<<< DPR\n");

	return 0;
}


int view_diameter()
{
	Diameter diameter;
	//uint8_t buf[] = { 0x01, 0x00, 0x02, 0x00, 0xC0, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x41, 0xC9, 0x00, 0x00, 0x41, 0xC9, 0x00, 0x00, 0x01, 0x07, 0x40, 0x00, 0x00, 0x29, 0x63, 0x68, 0x61, 0x72, 0x67, 0x65, 0x34, 0x2E, 0x67, 0x6D, 0x63, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x3B, 0x33, 0x36, 0x38, 0x32, 0x31, 0x34, 0x39, 0x38, 0x33, 0x37, 0x3B, 0x31, 0x36, 0x38, 0x34, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x40, 0x00, 0x00, 0x18, 0x63, 0x68, 0x61, 0x72, 0x67, 0x65, 0x34, 0x2E, 0x67, 0x6D, 0x63, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x28, 0x40, 0x00, 0x00, 0x0F, 0x63, 0x68, 0x61, 0x72, 0x67, 0x65, 0x34, 0x00, 0x00, 0x00, 0x01, 0x25, 0x40, 0x00, 0x00, 0x11, 0x44, 0x63, 0x63, 0x50, 0x72, 0x6F, 0x78, 0x79, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1B, 0x40, 0x00, 0x00, 0x19, 0x77, 0x77, 0x77, 0x2E, 0x44, 0x63, 0x63, 0x50, 0x72, 0x6F, 0x78, 0x79, 0x33, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0xCD, 0x40, 0x00, 0x00, 0x1A, 0x6D, 0x61, 0x6E, 0x61, 0x67, 0x65, 0x72, 0x40, 0x68, 0x75, 0x61, 0x77, 0x65, 0x69, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x01, 0xA0, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0x9F, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x40, 0x00, 0x00, 0x0C, 0xDB, 0x79, 0x25, 0xCD, 0x00, 0x00, 0x01, 0xBB, 0x40, 0x00, 0x00, 0x28, 0x00, 0x00, 0x01, 0xC2, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xBC, 0x40, 0x00, 0x00, 0x13, 0x31, 0x33, 0x37, 0x32, 0x36, 0x37, 0x33, 0x34, 0x30, 0x35, 0x30, 0x00, 0x00, 0x00, 0x01, 0xB4, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xB7, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x03, 0x69, 0xC0, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x28, 0xAF, 0x00, 0x00, 0x4F, 0x4C, 0xC0, 0x00, 0x00, 0xD0, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x51, 0x18, 0xC0, 0x00, 0x00, 0xC4, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x51, 0x19, 0x40, 0x00, 0x00, 0x10, 0x30, 0x31, 0x30, 0x31, 0x30, 0x33, 0x30, 0x31, 0x00, 0x00, 0x51, 0x1A, 0x00, 0x00, 0x00, 0x28, 0x4E, 0x53, 0x30, 0x39, 0x39, 0x39, 0x30, 0x34, 0x30, 0x35, 0x37, 0x36, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x30, 0x33, 0x35, 0x30, 0x35, 0x35, 0x37, 0x37, 0x32, 0x33, 0x33, 0x00, 0x00, 0x50, 0xB3, 0x40, 0x00, 0x00, 0x16, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x39, 0x32, 0x33, 0x35, 0x37, 0x00, 0x00, 0x00, 0x00, 0x51, 0x1B, 0x40, 0x00, 0x00, 0x28, 0x4E, 0x53, 0x30, 0x39, 0x39, 0x39, 0x30, 0x34, 0x30, 0x35, 0x37, 0x36, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x30, 0x33, 0x35, 0x30, 0x35, 0x35, 0x37, 0x37, 0x32, 0x33, 0x33, 0x00, 0x00, 0x51, 0x1C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x51, 0x1D, 0x40, 0x00, 0x00, 0x13, 0x31, 0x33, 0x37, 0x32, 0x36, 0x37, 0x33, 0x34, 0x30, 0x35, 0x30, 0x00, 0x00, 0x00, 0x51, 0x1E, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x50, 0xAC, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x51, 0x1F, 0x00, 0x00, 0x00, 0x0A, 0x30, 0x34, 0x00, 0x00};
	uint8_t buf[] = { 0x01, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x41, 0xC9, 0x00, 0x00, 0x41, 0xC9, 0x00, 0x00, 0x01, 0x07, 0x40, 0x00, 0x00, 0x29, 0x63, 0x68, 0x61, 0x72, 0x67, 0x65, 0x34, 0x2E, 0x67, 0x6D, 0x63, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x3B, 0x33, 0x36, 0x38, 0x32, 0x31, 0x34, 0x39, 0x38, 0x33, 0x37, 0x3B, 0x31, 0x36, 0x38, 0x34, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0C, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x07, 0xD1, 0x00, 0x00, 0x01, 0x08, 0x40, 0x00, 0x00, 0x11, 0x44, 0x63, 0x63, 0x50, 0x72, 0x6F, 0x78, 0x79, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x28, 0x40, 0x00, 0x00, 0x19, 0x77, 0x77, 0x77, 0x2E, 0x44, 0x63, 0x63, 0x50, 0x72, 0x6F, 0x78, 0x79, 0x33, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0xA0, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0x9F, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x16, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x37, 0x40, 0x00, 0x00, 0x0C, 0xDB, 0x79, 0x25, 0xCD, 0x00, 0x00, 0x01, 0x1A, 0x40, 0x00, 0x00, 0x11, 0x44, 0x63, 0x63, 0x50, 0x72, 0x6F, 0x78, 0x79, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x69, 0x80, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x28, 0xAF, 0x00, 0x00, 0x4F, 0x4C, 0x80, 0x00, 0x00, 0xA8, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x51, 0x18, 0x80, 0x00, 0x00, 0x9C, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x51, 0x19, 0x80, 0x00, 0x00, 0x14, 0x00, 0x01, 0x3C, 0x68, 0x30, 0x31, 0x30, 0x31, 0x30, 0x33, 0x30, 0x31, 0x00, 0x00, 0x51, 0x1A, 0x80, 0x00, 0x00, 0x2C, 0x00, 0x01, 0x3C, 0x68, 0x4E, 0x53, 0x30, 0x39, 0x39, 0x39, 0x30, 0x34, 0x30, 0x35, 0x37, 0x36, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x30, 0x33, 0x35, 0x30, 0x35, 0x35, 0x37, 0x37, 0x32, 0x33, 0x33, 0x00, 0x00, 0x50, 0xB3, 0x80, 0x00, 0x00, 0x1A, 0x00, 0x01, 0x3C, 0x68, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x39, 0x32, 0x33, 0x35, 0x37, 0x00, 0x00, 0x00, 0x00, 0x51, 0x20, 0x80, 0x00, 0x00, 0x10, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x21, 0x80, 0x00, 0x00, 0x14, 0x00, 0x01, 0x3C, 0x68, 0x32, 0x30, 0x33, 0x37, 0x30, 0x31, 0x30, 0x31, 0x00, 0x00, 0x51, 0x22, 0x80, 0x00, 0x00, 0x10, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x94, 0x52 };
	diameter.parse_from_buffer(buf, sizeof(buf));
	diameter.dump();

	return 0;
}


int view_avp()
{
	Avp avp;
	//uint8_t buf[] = { 0x00, 0x00, 0x4F, 0x4C, 0xC0, 0x00, 0x00, 0xD0, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x51, 0x18, 0xC0, 0x00, 0x00, 0xC4, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x51, 0x19, 0x40, 0x00, 0x00, 0x10, 0x30, 0x31, 0x30, 0x31, 0x30, 0x33, 0x30, 0x31, 0x00, 0x00, 0x51, 0x1A, 0x00, 0x00, 0x00, 0x28, 0x4E, 0x53, 0x30, 0x39, 0x39, 0x39, 0x30, 0x34, 0x30, 0x35, 0x37, 0x36, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x30, 0x33, 0x35, 0x30, 0x35, 0x35, 0x37, 0x37, 0x32, 0x34, 0x31, 0x00, 0x00, 0x50, 0xB3, 0x40, 0x00, 0x00, 0x16, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x30, 0x33, 0x35, 0x30, 0x35, 0x00, 0x00, 0x00, 0x00, 0x51, 0x1B, 0x40, 0x00, 0x00, 0x28, 0x4E, 0x53, 0x30, 0x39, 0x39, 0x39, 0x30, 0x34, 0x30, 0x35, 0x37, 0x36, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x30, 0x33, 0x35, 0x30, 0x35, 0x35, 0x37, 0x37, 0x32, 0x34, 0x31, 0x00, 0x00, 0x51, 0x1C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x51, 0x1D, 0x40, 0x00, 0x00, 0x13, 0x31, 0x35, 0x30, 0x38, 0x39, 0x33, 0x34, 0x31, 0x30, 0x30, 0x31, 0x00, 0x00, 0x00, 0x51, 0x1E, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x01, 0x86, 0xA0, 0x00, 0x00, 0x50, 0xAC, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x51, 0x1F, 0x00, 0x00, 0x00, 0x0A, 0x30, 0x34, 0x00, 0x00};
	//uint8_t buf[] = { 0x00, 0x00, 0x4F, 0x4C, 0xC0, 0x00, 0x00, 0xD0, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x51, 0x18, 0xC0, 0x00, 0x00, 0xC4, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x51, 0x19, 0x40, 0x00, 0x00, 0x10, 0x30, 0x31, 0x30, 0x31, 0x30, 0x33, 0x30, 0x31, 0x00, 0x00, 0x51, 0x1A, 0x40, 0x00, 0x00, 0x28, 0x4E, 0x53, 0x30, 0x39, 0x39, 0x39, 0x30, 0x34, 0x30, 0x35, 0x37, 0x36, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x30, 0x33, 0x35, 0x30, 0x35, 0x35, 0x37, 0x37, 0x32, 0x33, 0x33, 0x00, 0x00, 0x50, 0xB3, 0x40, 0x00, 0x00, 0x16, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x36, 0x33, 0x39, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x51, 0x1B, 0x40, 0x00, 0x00, 0x28, 0x4E, 0x53, 0x30, 0x39, 0x39, 0x39, 0x30, 0x34, 0x30, 0x35, 0x37, 0x36, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x30, 0x33, 0x35, 0x30, 0x35, 0x35, 0x37, 0x37, 0x32, 0x33, 0x33, 0x00, 0x00, 0x51, 0x1C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x51, 0x1D, 0x40, 0x00, 0x00, 0x13, 0x31, 0x33, 0x37, 0x32, 0x36, 0x37, 0x33, 0x34, 0x30, 0x35, 0x30, 0x00, 0x00, 0x00, 0x51, 0x1E, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x50, 0xAC, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x51, 0x1F, 0x00, 0x00, 0x00, 0x0A, 0x30, 0x34, 0x00, 0x00};
	uint8_t buf[] = { 0x00, 0x00, 0x4F, 0x4C, 0x80, 0x00, 0x00, 0xA8, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x51, 0x18, 0x80, 0x00, 0x00, 0x9C, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x51, 0x19, 0x80, 0x00, 0x00, 0x14, 0x00, 0x01, 0x3C, 0x68, 0x30, 0x31, 0x30, 0x31, 0x30, 0x34, 0x30, 0x31, 0x00, 0x00, 0x51, 0x1A, 0x80, 0x00, 0x00, 0x2C, 0x00, 0x01, 0x3C, 0x68, 0x4E, 0x53, 0x30, 0x39, 0x39, 0x39, 0x30, 0x34, 0x30, 0x35, 0x37, 0x36, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x30, 0x33, 0x35, 0x30, 0x35, 0x35, 0x37, 0x37, 0x32, 0x33, 0x32, 0x00, 0x00, 0x50, 0xB3, 0x80, 0x00, 0x00, 0x1A, 0x00, 0x01, 0x3C, 0x68, 0x32, 0x30, 0x31, 0x36, 0x30, 0x39, 0x30, 0x36, 0x31, 0x39, 0x32, 0x33, 0x35, 0x37, 0x00, 0x00, 0x00, 0x00, 0x51, 0x20, 0x80, 0x00, 0x00, 0x10, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x21, 0x80, 0x00, 0x00, 0x14, 0x00, 0x01, 0x3C, 0x68, 0x32, 0x30, 0x33, 0x37, 0x30, 0x31, 0x30, 0x31, 0x00, 0x00, 0x51, 0x22, 0x80, 0x00, 0x00, 0x10, 0x00, 0x01, 0x3C, 0x68, 0x00, 0x00, 0x90, 0x6A};
	Avp::extract_one_avp(buf, sizeof(buf), avp);
	avp.dump_avp();

	vector<Avp> avps;
	avp.get_grouped(avps);
	assert(avps.size() == 1);
	avps[0].dump_avp();

	avp = avps[0];
	avps.clear();
	avp.get_grouped(avps);

	for (auto it = avps.begin(); it != avps.end(); ++it)
	{
		printf("=========================*******************************======================\n");
		it->dump_avp();
	}
	return 0;
}

